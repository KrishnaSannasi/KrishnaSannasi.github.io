<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Closures: Magic Functions | Rusty Yato</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Closures: Magic Functions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="If you want to respond to this post, please respond via Rust users or Reddit." />
<meta property="og:description" content="If you want to respond to this post, please respond via Rust users or Reddit." />
<link rel="canonical" href="http://localhost:4000/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html" />
<meta property="og:url" content="http://localhost:4000/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html" />
<meta property="og:site_name" content="Rusty Yato" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-17T12:00:00-07:00" />
<script type="application/ld+json">
{"datePublished":"2019-01-17T12:00:00-07:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html"},"url":"http://localhost:4000/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html","description":"If you want to respond to this post, please respond via Rust users or Reddit.","headline":"Closures: Magic Functions","dateModified":"2019-01-17T12:00:00-07:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Rusty Yato" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Rusty Yato</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Closures: Magic Functions</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-01-17T12:00:00-07:00" itemprop="datePublished">Jan 17, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>If you want to respond to this post, please respond via <a href="https://users.rust-lang.org/t/blog-closures-magic-functions/24306">Rust users</a> or <a href="https://www.reddit.com/r/rust/comments/ah307y/blog_closures_magic_functions/">Reddit</a>.</p>

<hr />

<p>Closures seem like magical functions. They can do magic like capture their enviornment, which normal functions can’t do.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hello_world</span> <span class="o">=</span> <span class="s">"Hello World!"</span><span class="nf">.to_string</span><span class="p">();</span>

<span class="k">let</span> <span class="n">closure</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">hello_world</span><span class="p">);</span>

<span class="c">// error[E0434]: can't capture dynamic environment in a fn item</span>
<span class="c">// fn normal_function() {</span>
<span class="c">//     println!("{}", hello_world)</span>
<span class="c">// }</span>
</code></pre></div></div>

<p>How does this work?</p>

<p>The first thing to understand about closures is that they are pure sugar, and three traits working in concert.</p>

<h2 id="fn-traits">Fn* Traits</h2>

<p>The three traits are</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span><span class="p">;</span> <span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span> <span class="p">}</span>
<span class="k">trait</span> <span class="n">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span> <span class="p">}</span>
<span class="k">trait</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>
<p><em>note</em> I have removed some unnecessary details, like function calling convention to simplify. You can see the docs for more info about each one here: <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a>.</p>

<p>These traits are critical to how closures work, so let’s delve into how they work.</p>

<h3 id="args">Args</h3>

<p>First the type parameter: <code class="highlighter-rouge">Args</code></p>

<p><code class="highlighter-rouge">Args</code> must always be a tuple representing the arguments of the closure. 
for example</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">||</span> <span class="s">"hi"</span><span class="p">;</span>               <span class="c">// this has Args = ()</span>
<span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">u32</span><span class="p">|</span> <span class="p">();</span>           <span class="c">// this has Args = (u32,)</span>
<span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">String</span><span class="p">|</span> <span class="n">a</span><span class="p">;</span> <span class="c">// this has Args = (f32, String)</span>
</code></pre></div></div>

<p>This is to get around needing varadict generics to handle every possible list of arguments.
This representation is unstable, and may change in the future. So instead of using the <code class="highlighter-rouge">Fn*</code> traits
directly, you can use them like so</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u32</span>
<span class="nf">FnMut</span><span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="p">)</span>
<span class="nf">FnOnce</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span>
</code></pre></div></div>

<h3 id="output">Output</h3>

<p>Next is type associated type <code class="highlighter-rouge">Output</code>.</p>

<p>This is quite simple, it just represents the output type of the closure.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">||</span> <span class="s">"hi"</span><span class="p">;</span>               <span class="c">// this has Output = &amp;'static str</span>
<span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">u32</span><span class="p">|</span> <span class="p">();</span>           <span class="c">// this has Output = ()</span>
<span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">String</span><span class="p">|</span> <span class="n">a</span><span class="p">;</span> <span class="c">// this has Output = f32</span>
</code></pre></div></div>

<h3 id="call">call*</h3>

<p>Finally is the functions</p>

<p><code class="highlighter-rouge">fn call*(self, args: Args) -&gt; Self::Output;</code></p>

<p>These functions do the leg work of executing the closure. There are a few notable differences between each one.</p>

<ul>
  <li>In <code class="highlighter-rouge">FnOnce</code> we have <code class="highlighter-rouge">call_once</code>, which takes a <code class="highlighter-rouge">self</code> reciever. This is how it enforces that it is only called once. After self is moved into this function call, it can’t be used again.</li>
  <li>In <code class="highlighter-rouge">FnMut</code> we have <code class="highlighter-rouge">call_mut</code>, which takes a <code class="highlighter-rouge">&amp;mut self</code> reciever. This allows changes to the enviornment in closures.</li>
  <li>In <code class="highlighter-rouge">Fn</code> we have <code class="highlighter-rouge">call</code>, which takes a <code class="highlighter-rouge">&amp;self</code> reciever. This doesn’t allow chagnes to the enviornment (ignoring shared mutablility), but it does make it the most flexible type of closure. It can be called as many times as you want, and it can be thread-safe if <code class="highlighter-rouge">Send</code> and <code class="highlighter-rouge">Sync</code> are also implemented for the closure.</li>
</ul>

<h2 id="examples">Examples</h2>

<p>I believe that working by example is the best way to explain something.</p>

<p>I will show the desugaring of a few closures, and explain why they are that way, and some benefits and costs to each closure.</p>

<p>Note: I will not show how <code class="highlighter-rouge">Send</code> and <code class="highlighter-rouge">Sync</code> are impled, as that is out of scope. After the first desugaring, I will not show the impls for all three <code class="highlighter-rouge">Fn*</code> traits, only the most specific one. So if you see <code class="highlighter-rouge">Fn</code>, then assume <code class="highlighter-rouge">FnMut</code> and <code class="highlighter-rouge">FnOnce</code> are impled with the same function body. If you see <code class="highlighter-rouge">FnMut</code>, then assume that <code class="highlighter-rouge">FnOnce</code> is impled with the same function body, but <code class="highlighter-rouge">Fn</code> is <em>not</em> impled. If you see <code class="highlighter-rouge">FnOnce</code>, then assume that <code class="highlighter-rouge">Fn</code> and <code class="highlighter-rouge">FnMut </code>are <em>not</em> impled. I will also put <code class="highlighter-rouge">type Output</code> in a comment to show what it would be if I only impl <code class="highlighter-rouge">Fn</code> or <code class="highlighter-rouge">FnMut</code>.</p>

<hr />
<p>First, the simplest closure, one that doesn’t capture anything, and only returns a unit.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">||</span> <span class="p">();</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nf">x</span><span class="p">();</span>
</code></pre></div></div>
<p>gets desugarred to</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Clone</span><span class="p">,</span> <span class="nb">Copy</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">__closure_0__</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">FnOnce</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_0__</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>
    
    <span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="p">())</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
        <span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FnMut</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_0__</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="p">())</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
        <span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_0__</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">():</span> <span class="p">())</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
        <span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">__closure_0__</span> <span class="p">{};</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Fn</span><span class="p">::</span><span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="p">());</span>
</code></pre></div></div>

<p>Now, there is quite a bit to unpack here. First we get this new type <code class="highlighter-rouge">__closure_0__</code>. We can also see that <code class="highlighter-rouge">Clone</code> and <code class="highlighter-rouge">Copy</code> are derived for <code class="highlighter-rouge">__closure_0__</code>. This is because it is an empty type so it is trivial to <code class="highlighter-rouge">Clone</code> and <code class="highlighter-rouge">Copy</code> an empty struct. This allows for more flexiblity when using the closure.</p>

<p>Rust will pick the most specific <code class="highlighter-rouge">Fn*</code> trait to use whenever you call a function, in this order: <code class="highlighter-rouge">Fn</code>, <code class="highlighter-rouge">FnMut</code>, <code class="highlighter-rouge">FnOnce</code>. So in this case, because we can implement <code class="highlighter-rouge">Fn</code>, we implement that and all pre-requisites (<code class="highlighter-rouge">FnMut</code> and <code class="highlighter-rouge">FnOnce</code>). The function body from the closure is copied over to the function body of each of <code class="highlighter-rouge">call*</code> functions.</p>

<p>Then create the closure by creating this new struct. We call the closure by calling the most specific <code class="highlighter-rouge">call*</code> function, which in this case is <code class="highlighter-rouge">call</code>.</p>

<p><em>Note:</em> the names I give, <code class="highlighter-rouge">__closure_0__</code> are arbitrary and the names that are actually used are random. This makes closures unnameable.</p>

<p><em>Note:</em> How Rust knows which <code class="highlighter-rouge">Fn*</code> trait to derive for the closure is up to analysis of what it captures and how it is used (seen later).</p>

<p>You can use these playground links to test out the desugared code!</p>

<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d43d7b0894c41e78365413a56bcfb20d">Playground Link</a></p>

<hr />
<p>Now one step up, lets capture a variable.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello World!"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">print_me</span> <span class="o">=</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>

<span class="nf">print_me</span><span class="p">();</span>
</code></pre></div></div>
<p>desugars to</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Clone</span><span class="p">,</span> <span class="nb">Copy</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">__closure_1__</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c">// note: lifetime parameter</span>
    <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">String</span><span class="p">,</span> <span class="c">// note: &amp;String, not String</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_1__</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// type Output = ();</span>
    
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">():</span> <span class="p">())</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="o">*</span><span class="k">self</span><span class="py">.message</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello World!"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">print_me</span> <span class="o">=</span> <span class="n">__closure_1__</span> <span class="p">{</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">message</span> <span class="p">};</span>


<span class="nn">Fn</span><span class="p">::</span><span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">print_me</span><span class="p">,</span> <span class="p">());</span>
</code></pre></div></div>
<p>We now have a field on <code class="highlighter-rouge">__closure_1__</code>, this represents the enviornment that is being used. So when we go to implement the <code class="highlighter-rouge">Fn*</code> traits, we use these fields to get access to the enviornment. Whenever Rust accesses one of these fields, it first dereferences them, the reason why will become evident when we get to mutating closures.</p>

<p>Notice the lifetime parameter on <code class="highlighter-rouge">__closure_1__</code>, because it is borrowing from the stack frame with <code class="highlighter-rouge">&amp;message</code>, <code class="highlighter-rouge">print_me</code> has a non-<code class="highlighter-rouge">'static</code> lifetime. One downside to this is that it can’t be sent across threads! Threads require a <code class="highlighter-rouge">'static</code> lifetime so that things don’t deallocate while they run.</p>

<p>We still maintain <code class="highlighter-rouge">Clone</code> and <code class="highlighter-rouge">Copy</code> because shared references are <code class="highlighter-rouge">Copy</code>.</p>

<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c6e017ceb489566268b1f0fd28f8be04">Playground Link</a></p>

<hr />
<p>Now, what about if I have a closure with arguments? What about <code class="highlighter-rouge">move</code> closures?</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">header</span> <span class="o">=</span> <span class="s">"PrintMe: "</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">print_me</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">message</span><span class="p">|</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>

<span class="nf">print_me</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
</code></pre></div></div>
<p>desugars to</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Clone</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">__closure_2__</span> <span class="p">{</span> <span class="c">// note: no lifetime parameter</span>
    <span class="n">header</span><span class="p">:</span> <span class="nb">String</span>     <span class="c">// note: String, not &amp;String</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,)</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_2__</span> <span class="p">{</span>
    <span class="c">// type Output = ();</span>
    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">(</span><span class="n">message</span><span class="p">,):</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,))</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.header</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">header</span> <span class="o">=</span> <span class="s">"PrintMe: "</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">print_me</span> <span class="o">=</span> <span class="n">__closure_2__</span> <span class="p">{</span>
     <span class="n">header</span><span class="p">:</span> <span class="n">header</span> <span class="c">// note: no &amp;</span>
<span class="p">};</span>

<span class="nn">Fn</span><span class="p">::</span><span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">print_me</span><span class="p">,</span> <span class="p">(</span><span class="s">"Hello World!"</span><span class="p">,));</span>
</code></pre></div></div>
<p>First, the types of the closure arguments are resolved via type inference.</p>

<p>Next, how are arguments handled? As we saw earlier in the <code class="highlighter-rouge">Fn* Traits</code> section, arguments are really just a single tuple containing all of the arguments. This tuple is automatically created whenever we call a closure and destructured inside the <code class="highlighter-rouge">call*</code> function.</p>

<p>Finally, what did <code class="highlighter-rouge">move</code> do? Simply, instead of borrowing from the enviornment, we are going to move everything from the enviornment into this new anonomous struct (<code class="highlighter-rouge">__closure_2__</code>). Now because <code class="highlighter-rouge">__closure_2__</code> doesn’t contain any lifetimes, it has a <code class="highlighter-rouge">'static</code> lifetime, which is necessary for it to be sent across threads! But in doing so, we also lost <code class="highlighter-rouge">Copy</code>, now our closure in only <code class="highlighter-rouge">Clone</code>. :(</p>

<p>This is why when you do anything with threads, you need to use <code class="highlighter-rouge">move</code> closures. They eliminate many of the references that would otherwise be created.</p>

<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=4ebcba27e4163605964645b1f553c5f2">Playground Link</a></p>

<hr />
<p>More on <code class="highlighter-rouge">move</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">a_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

<span class="k">let</span> <span class="n">print_me</span> <span class="o">=</span> <span class="k">move</span> <span class="p">||</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">a_ref</span><span class="p">);</span>

<span class="nf">print_me</span><span class="p">();</span>
</code></pre></div></div>
<p>desugars to</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// lifetimes are back, even though this is a `move` closure</span>
<span class="c">// because this closure captures a reference</span>
<span class="c">// note: a new lifetime parameter will be created for</span>
<span class="c">// user-defined structs that also have lifetime parameters.</span>
<span class="nd">#[derive(Clone,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">__closure_3__</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">a_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Fn</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_3__</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// type Output = ();</span>

    <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">():</span> <span class="p">())</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.a_ref</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">a_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

<span class="c">// because this is a move closure, there are no new references here</span>
<span class="k">let</span> <span class="n">print_me</span> <span class="o">=</span> <span class="n">__closure_3__</span> <span class="p">{</span> <span class="n">a_ref</span><span class="p">:</span> <span class="n">a_ref</span> <span class="p">};</span>

<span class="nn">Fn</span><span class="p">::</span><span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">print_me</span><span class="p">,</span> <span class="p">());</span>
</code></pre></div></div>

<p>Notice that even though we have a <code class="highlighter-rouge">move</code> closure, we still get lifetimes. This is because we have a reference from the enviornment. This means that unless that reference resolves to be <code class="highlighter-rouge">'static</code>, you cannot send it across threads. In this case the reference is definitely a shorter lifetime than <code class="highlighter-rouge">'static</code></p>

<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bdb0e9a398b07e3bead33b2ddf952edf">Playground Link</a></p>

<hr />
<p>What about returning things from closures, and mutating the enviornment inside a closure.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
    <span class="n">counter</span>
<span class="p">};</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">next</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">next</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">next</span><span class="p">(),</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div></div>
<p>desugars to</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__closure_4__</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'b</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">counter</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'b</span> <span class="nb">u32</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'b</span><span class="o">&gt;</span> <span class="n">FnMut</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_4__</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'b</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// type Output = u32;</span>

    <span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="p">():</span> <span class="p">())</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.counter</span> <span class="o">+=</span> <span class="o">*</span><span class="k">self</span><span class="py">.delta</span><span class="p">;</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.counter</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">let</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="n">__closure_4__</span> <span class="p">{</span>
    <span class="n">counter</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">counter</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">delta</span>
<span class="p">};</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">FnMut</span><span class="p">::</span><span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">next</span><span class="p">,</span> <span class="p">()),</span> <span class="mi">2</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">FnMut</span><span class="p">::</span><span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">next</span><span class="p">,</span> <span class="p">()),</span> <span class="mi">4</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">FnMut</span><span class="p">::</span><span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">next</span><span class="p">,</span> <span class="p">()),</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div></div>

<p>Because we are changing counter inside of the closure, we can implement at most <code class="highlighter-rouge">FnMut</code>. This is because we don’t have write access inside of <code class="highlighter-rouge">Fn</code>.</p>

<p>We take a <code class="highlighter-rouge">&amp;mut</code> to <code class="highlighter-rouge">counter</code> so that we can change it, and a <code class="highlighter-rouge">&amp;</code> to delta to read from it. Each reference gets a fresh lifetime parameter.</p>

<p>We can now see why we need to dereference the references inside of <code class="highlighter-rouge">call*</code>. This is because we need the correct types for things to work out. For example, there is no impl of <code class="highlighter-rouge">AddAssign</code> for <code class="highlighter-rouge">&amp;mut u32</code>, but there is one for <code class="highlighter-rouge">u32</code>. So we need to dereference <code class="highlighter-rouge">self.counter</code> so that Rust can resolve <code class="highlighter-rouge">AddAssign</code> correctly. There is nothing special about <code class="highlighter-rouge">AddAssign</code>,  type inference requires that these types are dereferenced in order to work correctly.</p>

<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=0fa923cb58ee9077b7788b37aa0ff372">Playground Link</a></p>

<hr />
<p>What about consuming things in a closure</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">];</span>

<span class="c">// notice, no `move`</span>
<span class="k">let</span> <span class="n">transform</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">a</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">transform</span><span class="p">());</span>
<span class="c">// println!("{}", transform()); // error[E0382]: use of moved value: `transform`</span>
</code></pre></div></div>
<p>desugars to</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="p">[</span><span class="nf">derive</span><span class="p">(</span><span class="n">Clone</span><span class="p">)]</span>
<span class="k">struct</span> <span class="n">__closure_5__</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> 
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FnOnce</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">__closure_5__</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>
    
    <span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="p">():</span> <span class="p">())</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="k">self</span><span class="py">.a</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">a</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">];</span>

<span class="k">let</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">__closure_5__</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">FnOnce</span><span class="p">::</span><span class="nf">call_once</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="p">()));</span>
<span class="c">// println!("{}", transform.call_once(())); // error[E0382]: use of moved value: `transform`</span>
</code></pre></div></div>

<p>Even though we didn’t add the <code class="highlighter-rouge">move</code> qualifier to the closure we see that <code class="highlighter-rouge">a</code> was moved into the closure. This is because <code class="highlighter-rouge">Vec::into_iter</code> takes <code class="highlighter-rouge">self</code> be value, which means <code class="highlighter-rouge">self</code> will be moved into the function. Because of this, the Rust moves a into <code class="highlighter-rouge">__closure_5__</code>. This means that <code class="highlighter-rouge">a</code> must be consumed during the function call, only <code class="highlighter-rouge">FnOnce</code> can be implemented.</p>

<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=ca812f04fd250c760c5fbc328d9590fe">Playground Link</a></p>

  </div><a class="u-url" href="/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Rusty Yato</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Rusty Yato</li><li><a class="u-email" href="mailto:krishna.sd.2012@gmail.com">krishna.sd.2012@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/KrishnaSannasi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">KrishnaSannasi</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A blog about the Rust Programming Language! Here we will delve into various parts of Rust and see how it works.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
